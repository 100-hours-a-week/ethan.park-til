### 새로 배운 내용 : 모듈

## 모듈

모듈이란?

- 독립성과 은닉성을 만족하며 연관된 코드들의 묶음
    - 독립성 : 모듈은 독립적이어야 한다
    - 은닉성 : 모듈의 사용자는 모듈의 내부 구현을 몰라도 된다. 공개된 인터페이스를 이용해 모듈과 통신한다

모듈 시스템이란?

- 연관된 코드 묶음이 ‘모듈성’을 갖출 수 있게 도와주는 시스템적인 해결책
- 모듈성을 지원하기 위해 모듈 시스템은 다음과 같은 기능을 필수적으로 지원해야 한다
    - 의존성 관리 : 모듈을 사용하기 위해 어떤 의존성이 필요한 지 명시할 수 있어야 한다
    - 캡슐화 관리 : 모듈은 불필요한 구현을 외부로 드러내지 않아야 한다

<aside>
💡

- 모듈은 연관된 코드의 묶음이 모듈성을 갖춘 경우 모듈이라고 부를 수 있다
- 모듈성에는 독립성과 은닉성이라는 특징이 있다
- 모듈성을 갖출 수 있게 도와주는 시스템이 모듈 시스템이다
- 모듈 시스템은 모듈성 중 독립성을 지원하기 위해 의존성 관리 기능을 지원할 수 있어야 한다
- 모듈 시스템은 모듈성 중 은닉성을 지원하기 위해 캡슐화 관리 기능을 지원할 수 있어야 한다
</aside>

<aside>
💡

- 패키지 시스템은 모듈 시스템이 될 수 없다
    - 패키지 수준의 의존성 관리와 캡슐화 관리 기능을 지원하지 않기 때문
    - 하지만, 패키지를 만들 때도 모듈처럼 독립성과 은닉성을 추구하는 것이 좋다
</aside>

### 독립성

- 모듈은 독립적이어야 한다
    - = 모듈이 다른 모듈이나 컴포넌트에 강하게 의존하지 않고 각 모듈을 개별적으로 수정하거나 교체할 수 있어야 한다
    - 유지보수를 용이하게 하고, 확장성을 높이고, 코드의 재사용성을 높이기 위함
    - 독립적인 모듈은 개발 과정에서의 효율성을 높이고 시스템 전체의 안정성을 유지하는 데 도움이 되며 코드를 테스트하기 쉽게 만들 수 있어 전체 시스템의 품질을 높이는 데 기여
    - 독립적이기 위해서 의존성을 관리할 수 있어야 한다
        - = 외부 모듈을 사용한다면 외부 모듈의 사용을 명시하라
- 모듈의 독립성을 보장하기 위해서는 모듈이 무엇인지 명확이 하면서도 연관된 코드만 모이도록 설계
- 하위 의존성 추적 기능으로 얻을 수 있는 또 다른 이점
    - 모듈 불러오는 것 자동화
    - 하위 모듈의 중복 검사와 불필요한 의존성 검사 가능
    - 하위 모듈에 보안 취약점 생기면 이를 사용하는 상위 모듈이 무엇인지 파악하기 쉬움

### 은닉성

- 모듈은 은닉성을 추구해야 한다
    - = 클래스가 은닉성을 추구하는 것처럼 모듈 수준의 캡슐화가 가능해야 한다
- 모듈을 외부에 공유하더라도 공개된 인터페이스 이외에 불필요한 정보를 숨길 수 있어야 한다
    - 모듈 수준의 인터페이스 관리가 필요
    - 모듈을 사용한다 ≠ 모듈의 모든 기능을 사용할 수 있게 된다
    - 모듈의 사용자는 모듈이 책임지는 공개된 일부 기능에만 접근할 수 있어야 한다

<aside>
💡

- MSA는 작은 단위의 독립된 애플리케이션을 여러 개 만들어 하나의 시스템이 동작하게 만드는 것
</aside>

## 패키지 구조

### 계층 기반 구조

- 계층 기반 구조는 레이어드 아키텍처를 사용하는 프로젝트에서 자주 보이는 패키지 구성 방식
- 최상단 패키지에 레이어드 아키텍처의 계층을 두고 해당 계층에 대응하는 컴포넌를 아래에 넣는 방식
- 예 : project/src/main/java/com/demo/myapp/presentation/UserController.java (or [PostController.java](http://PostController.java) 등등)
- 비즈니스 레이어에 repository 패키지를 하위 패키지로 설정
    - 구현체는 infrastructure 패키지에 넣는다
    - 이는 의존성 역전을 적용해 business 패키지가 infrastructure 패키지에 의존하지 않게 만들기 위함
- 장점
    - 이해하기 쉽다
    - 사용하기 쉽다
- 단점
    - 도메인이 눈에 들어오지 않는다
        - 패키지 구조를 통해 해당 애플리케이션이 어떤 애플리케이션인지 알기 힘들다
        - 애플리케이션에 어떤 도메인이 사용되는지 파악하려면 모든 계층을 열어보고 정리해야 한다
        - 도메인 관점의 응집도가 떨어지고, 비즈니스 코드를 한 곳에 모아볼 수 없다
            - 예 : UserController.java, UserService.java, User.java가 모두 다른 패키지에 분산

### 도메인 기반 구조

- 패키지 최상단에 프로그램이 사용하는 도메인이 오도록 구성
- 예 : project/src/main/java/com/demo/myapp/user/UserController.java ( or [User.java](http://User.java) or [UserService.java](http://UserService.java) 등등)
- 장점
    - 도메인 코드를 한 곳으로 모음으로써 비즈니스 코드가 여기저기 산개되지 않게 된다
    - 프로젝트의 패키지 최상단에 도메인을 드러내어 패키지 구조만 보고 해당 프로젝트가 어떤 도메인을 사용하고 있는지 알 수 있다
- 단점
    - 계층이 눈에 들어오지 않는다 (= 구조가 복잡)
        - 계층별로 대응되는 스프링 컴포넌트가 어디에 있는지도 눈에 안 들어온다
- 계층과 도메인 기반 구조를 합치면 독립성을 얻게 되며 계층에 따라 컴포넌트 확인 가능
    - project/src/main/java/com/demo/myapp/user/presentation/UserController.java
    - project/src/main/java/com/demo/myapp/user/domain/User.java
- DDD를 이용하는 프로젝트에서 자주 사용

<aside>
💡

- 작은 규모의 프로젝트라면 단순하고 직관적인 계층 기반 구조로 개발하는 것이 유리
- 큰 규모의 프로젝트라면 비즈니스 도메인의 복잡성을 관리하기 위해 도메인 기반 구조로 개발하는 것이 유리
</aside>
